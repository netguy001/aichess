<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive Chess AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Difficulty Selection Screen */
        .difficulty-screen {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 500px;
        }

        .difficulty-screen.hidden {
            display: none;
        }

        .difficulty-screen h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 36px;
        }

        .difficulty-screen p {
            color: #7f8c8d;
            margin-bottom: 40px;
            font-size: 18px;
        }

        .difficulty-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .diff-option {
            padding: 20px 40px;
            border: 3px solid #3498db;
            background: white;
            color: #2c3e50;
            border-radius: 12px;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .diff-option:hover {
            background: #3498db;
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(52, 152, 219, 0.4);
        }

        /* Game Container */
        .game-container {
            display: none;
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .game-container.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .main-game {
            display: flex;
            gap: 25px;
            align-items: center;
        }

        .board-wrapper {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 720px;
            height: 720px;
            border: 3px solid #2c3e50;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            user-select: none;
        }

        .square:hover {
            filter: brightness(1.1);
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px #f39c12;
        }

        .square.move-hint::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(39, 174, 96, 0.6);
            border-radius: 50%;
        }

        .square.capture-hint::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid rgba(231, 76, 60, 0.7);
            box-sizing: border-box;
        }

        .square.last-move {
            background-color: rgba(255, 235, 59, 0.5) !important;
        }

        .square.check-highlight {
            box-shadow: inset 0 0 0 5px #e74c3c !important;
            animation: checkPulse 1s infinite;
        }

        .square.castling-hint::after {
            content: 'üè∞';
            position: absolute;
            font-size: 30px;
        }

        .square.en-passant-hint::after {
            content: '‚ö°';
            position: absolute;
            font-size: 25px;
        }

        @keyframes checkPulse {

            0%,
            100% {
                box-shadow: inset 0 0 0 5px #e74c3c;
            }

            50% {
                box-shadow: inset 0 0 0 5px #c0392b;
            }
        }

        /* Themes */
        .theme-classic .light {
            background-color: #f0d9b5;
        }

        .theme-classic .dark {
            background-color: #b58863;
        }

        .theme-blue .light {
            background-color: #dee3e6;
        }

        .theme-blue .dark {
            background-color: #8ca2ad;
        }

        .theme-green .light {
            background-color: #ffffdd;
        }

        .theme-green .dark {
            background-color: #86a666;
        }

        .theme-purple .light {
            background-color: #e8e4f3;
        }

        .theme-purple .dark {
            background-color: #9b88b5;
        }

        .theme-red .light {
            background-color: #f4e4e4;
        }

        .theme-red .dark {
            background-color: #c97c7c;
        }

        /* Pawn Promotion Dialog */
        .promotion-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            text-align: center;
        }

        .promotion-dialog.active {
            display: block;
        }

        .promotion-dialog h2 {
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .promotion-options {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-piece {
            font-size: 60px;
            padding: 20px;
            border: 3px solid #3498db;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .promotion-piece:hover {
            background: #3498db;
            transform: scale(1.1);
        }

        .promotion-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
        }

        .promotion-overlay.active {
            display: block;
        }

        /* Status Bar */
        .status-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(52, 152, 219, 0.95);
            color: white;
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .status-bar.thinking {
            background: rgba(243, 156, 18, 0.95);
        }

        .status-bar.game-over {
            background: rgba(231, 76, 60, 0.95);
        }

        .status-bar.check-status {
            background: rgba(231, 76, 60, 0.95);
            animation: statusPulse 0.5s infinite;
        }

        @keyframes statusPulse {

            0%,
            100% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.05);
            }
        }

        /* Side Panels */
        .side-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            width: 220px;
        }

        .panel-section {
            margin-bottom: 15px;
        }

        .panel-section h3 {
            color: #2c3e50;
            font-size: 14px;
            margin-bottom: 8px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .compact-stats {
            font-size: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .stat-label {
            color: #7f8c8d;
        }

        .stat-value {
            color: #3498db;
            font-weight: bold;
        }

        /* Timer */
        .timer-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            margin-bottom: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .timer-label {
            font-size: 10px;
            opacity: 0.9;
            margin-bottom: 3px;
        }

        /* Captured Pieces */
        .captured-section {
            background: #ecf0f1;
            padding: 10px;
            border-radius: 6px;
            min-height: 60px;
        }

        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            font-size: 20px;
        }

        .captured-piece {
            opacity: 0.7;
        }

        /* Move History */
        .move-history {
            background: #ecf0f1;
            padding: 8px;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
        }

        .move-item {
            padding: 3px 5px;
            margin: 2px 0;
            background: white;
            border-radius: 3px;
        }

        /* Control Buttons */
        .control-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .compact-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .theme-btn-compact {
            background: #9b59b6;
            color: white;
        }

        .theme-btn-compact:hover {
            background: #8e44ad;
        }

        .new-game-compact {
            background: #27ae60;
            color: white;
        }

        .new-game-compact:hover {
            background: #229954;
        }

        .undo-compact {
            background: #f39c12;
            color: white;
            position: relative;
        }

        .undo-compact:hover:not(:disabled) {
            background: #e67e22;
        }

        .undo-compact:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .undo-timer {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hint-btn-compact {
            background: #3498db;
            color: white;
        }

        .hint-btn-compact:hover {
            background: #2980b9;
        }

        /* Theme Popup */
        .theme-popup {
            display: none;
            position: absolute;
            top: 60px;
            right: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .theme-popup.active {
            display: block;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .theme-option {
            padding: 8px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s;
        }

        .theme-option:hover {
            border-color: #3498db;
            transform: scale(1.05);
        }

        .theme-option.active {
            border-color: #3498db;
            background: #ebf5fb;
        }

        /* Game Over Modal */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            text-align: center;
            min-width: 400px;
        }

        .game-over-modal.active {
            display: block;
        }

        .game-over-modal h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .game-over-modal p {
            font-size: 18px;
            color: #7f8c8d;
            margin-bottom: 30px;
        }

        .game-over-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .game-over-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .new-game-btn {
            background: #27ae60;
            color: white;
        }

        .new-game-btn:hover {
            background: #229954;
            transform: scale(1.05);
        }

        .continue-btn {
            background: #3498db;
            color: white;
        }

        .continue-btn:hover {
            background: #2980b9;
            transform: scale(1.05);
        }

        @media (max-height: 850px) {
            .chessboard {
                width: 600px;
                height: 600px;
            }

            .square {
                font-size: 48px;
            }
        }
    </style>
</head>

<body>
    <!-- Difficulty Selection Screen -->
    <div class="difficulty-screen" id="difficultyScreen">
        <h1>‚ôüÔ∏è Chess AI</h1>
        <p>Choose your difficulty level</p>
        <div class="difficulty-options">
            <button class="diff-option" data-level="medium">üéØ Medium</button>
            <button class="diff-option" data-level="hard">üî• Hard</button>
            <button class="diff-option" data-level="impossible">üíÄ Impossible</button>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="gameContainer">
        <!-- Control Buttons -->
        <div class="control-buttons">
            <button class="compact-btn theme-btn-compact" id="themeToggle">üé® Theme</button>
            <button class="compact-btn hint-btn-compact" id="hintBtn">üí° Hint</button>
            <button class="compact-btn new-game-compact" id="newGameBtn">üîÑ New Game</button>
            <button class="compact-btn undo-compact" id="undoBtn" disabled>
                ‚Ü©Ô∏è Undo
                <span class="undo-timer" id="undoTimer"></span>
            </button>
        </div>

        <!-- Theme Popup -->
        <div class="theme-popup" id="themePopup">
            <div class="theme-grid">
                <div class="theme-option active" data-theme="classic">Classic</div>
                <div class="theme-option" data-theme="blue">Blue</div>
                <div class="theme-option" data-theme="green">Green</div>
                <div class="theme-option" data-theme="purple">Purple</div>
                <div class="theme-option" data-theme="red">Red</div>
            </div>
        </div>

        <div class="main-game">
            <!-- Left Panel -->
            <div class="side-panel">
                <!-- Timer -->
                <div class="timer-display">
                    <div class="timer-label">‚è±Ô∏è MATCH TIME</div>
                    <div id="matchTimer">00:00</div>
                </div>

                <!-- AI Stats -->
                <div class="panel-section">
                    <h3>üìä AI Stats</h3>
                    <div class="compact-stats">
                        <div class="stat-row">
                            <span class="stat-label">Games:</span>
                            <span class="stat-value" id="gamesPlayed">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">AI Wins:</span>
                            <span class="stat-value" id="aiWins">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">You Win:</span>
                            <span class="stat-value" id="playerWins">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Draws:</span>
                            <span class="stat-value" id="draws">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Win Rate:</span>
                            <span class="stat-value" id="winRate">0%</span>
                        </div>
                    </div>
                </div>

                <!-- Captured by AI -->
                <div class="panel-section">
                    <h3>ü§ñ AI Captured</h3>
                    <div class="captured-section">
                        <div class="captured-pieces" id="aiCaptured"></div>
                    </div>
                </div>
            </div>

            <!-- Chess Board -->
            <div class="board-wrapper">
                <div class="chessboard theme-classic" id="chessboard"></div>
            </div>

            <!-- Right Panel -->
            <div class="side-panel">
                <!-- Captured by Player -->
                <div class="panel-section">
                    <h3>üë§ You Captured</h3>
                    <div class="captured-section">
                        <div class="captured-pieces" id="playerCaptured"></div>
                    </div>
                </div>

                <!-- Move History -->
                <div class="panel-section">
                    <h3>üìú Moves</h3>
                    <div class="move-history" id="moveHistory">
                        <div style="text-align: center; color: #7f8c8d; font-size: 11px;">No moves yet</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="statusMessage">Your Turn - White</div>
    </div>

    <!-- Pawn Promotion Dialog -->
    <div class="promotion-overlay" id="promotionOverlay"></div>
    <div class="promotion-dialog" id="promotionDialog">
        <h2>Choose Promotion Piece</h2>
        <div class="promotion-options">
            <div class="promotion-piece" data-piece="q">‚ôõ</div>
            <div class="promotion-piece" data-piece="r">‚ôú</div>
            <div class="promotion-piece" data-piece="b">‚ôù</div>
            <div class="promotion-piece" data-piece="n">‚ôû</div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="promotion-overlay" id="gameOverOverlay"></div>
    <div class="game-over-modal" id="gameOverModal">
        <h2 id="gameOverTitle">Game Over!</h2>
        <p id="gameOverMessage">Result message here</p>
        <div class="game-over-buttons">
            <button class="game-over-btn new-game-btn" id="gameOverNewGame">üîÑ New Game</button>
            <button class="game-over-btn continue-btn" id="gameOverContinue">üëÄ View Board</button>
        </div>
    </div>

    <script>
        // Chess pieces unicode
        const pieces = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        // State variables
        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let difficulty = 'hard';
        let gameOver = false;
        let undoTimeout = null;
        let undoCountdown = null;
        let lastMove = null;
        let matchStartTime = null;
        let timerInterval = null;
        let capturedByPlayer = [];
        let capturedByAI = [];
        let playerInCheck = false;
        let aiInCheck = false;
        let moveHistory = [];
        let boardHistory = [];
        let pendingPromotion = null;

        // Difficulty selection
        document.querySelectorAll('.diff-option').forEach(btn => {
            btn.addEventListener('click', function () {
                difficulty = this.dataset.level;
                document.getElementById('difficultyScreen').classList.add('hidden');
                document.getElementById('gameContainer').classList.add('active');
                initGame();
            });
        });

        // Initialize game
        async function initGame() {
            const response = await fetch('/new_game', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const data = await response.json();

            if (data.success) {
                board = [
                    ["r", "n", "b", "q", "k", "b", "n", "r"],
                    ["p", "p", "p", "p", "p", "p", "p", "p"],
                    ["", "", "", "", "", "", "", ""],
                    ["", "", "", "", "", "", "", ""],
                    ["", "", "", "", "", "", "", ""],
                    ["", "", "", "", "", "", "", ""],
                    ["P", "P", "P", "P", "P", "P", "P", "P"],
                    ["R", "N", "B", "Q", "K", "B", "N", "R"]
                ];

                capturedByPlayer = [];
                capturedByAI = [];
                playerInCheck = false;
                aiInCheck = false;
                gameOver = false;
                currentPlayer = 'white';
                lastMove = null;
                moveHistory = [];
                boardHistory = [JSON.parse(JSON.stringify(board))];
                pendingPromotion = null;

                updateCapturedPieces();
                renderBoard();
                updateStatus();
                updateStats(data.stats);
                startTimer();
            }
        }

        // Timer functions
        function startTimer() {
            matchStartTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimer() {
            if (!matchStartTime) return;
            const elapsed = Math.floor((Date.now() - matchStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('matchTimer').textContent =
                `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Update captured pieces
        function updateCapturedPieces() {
            const playerCapturedEl = document.getElementById('playerCaptured');
            const aiCapturedEl = document.getElementById('aiCaptured');

            playerCapturedEl.innerHTML = capturedByPlayer.map(p =>
                `<span class="captured-piece">${pieces[p]}</span>`
            ).join('') || '<span style="color: #bdc3c7; font-size: 11px;">None</span>';

            aiCapturedEl.innerHTML = capturedByAI.map(p =>
                `<span class="captured-piece">${pieces[p]}</span>`
            ).join('') || '<span style="color: #bdc3c7; font-size: 11px;">None</span>';
        }

        // Helper functions
        function isWhitePiece(piece) {
            return piece && piece.toUpperCase() === piece;
        }

        function recordMove(fromR, fromC, toR, toC, isAI = false) {
            const piece = board[toR][toC];
            const fromNotation = String.fromCharCode(97 + fromC) + (8 - fromR);
            const toNotation = String.fromCharCode(97 + toC) + (8 - toR);

            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            moveItem.textContent = `${isAI ? 'ü§ñ' : 'üë§'} ${pieces[piece]} ${fromNotation}‚Üí${toNotation}`;

            const historyEl = document.getElementById('moveHistory');
            if (historyEl.children[0]?.textContent === 'No moves yet') {
                historyEl.innerHTML = '';
            }
            historyEl.appendChild(moveItem);
            historyEl.scrollTop = historyEl.scrollHeight;

            moveHistory.push({ from: { row: fromR, col: fromC }, to: { row: toR, col: toC }, isAI });
        }

        function clearHintMoves() {
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('move-hint', 'capture-hint', 'castling-hint', 'en-passant-hint');
            });
        }

        function clearSelection() {
            selectedSquare = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected');
            });
            clearHintMoves();
        }

        function highlightSquare(r, c) {
            clearSelection();
            selectedSquare = { r, c };
            const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
            if (square) square.classList.add('selected');
        }

        // Render board
        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = pieces[piece];
                    }

                    // Highlight King if in check
                    square.classList.remove('check-highlight');
                    if (piece && piece.toLowerCase() === 'k') {
                        if ((piece === 'K' && playerInCheck) || (piece === 'k' && aiInCheck)) {
                            square.classList.add('check-highlight');
                        }
                    }

                    // Highlight last move
                    square.classList.remove('last-move');
                    if (lastMove &&
                        ((lastMove.from.row === row && lastMove.from.col === col) ||
                            (lastMove.to.row === row && lastMove.to.col === col))) {
                        square.classList.add('last-move');
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }

            // Restore selected highlight
            if (selectedSquare) {
                const sel = document.querySelector(`[data-row="${selectedSquare.r}"][data-col="${selectedSquare.c}"]`);
                if (sel) sel.classList.add('selected');
            }
        }

        // Handle pawn promotion
        function showPromotionDialog(fromR, fromC, toR, toC) {
            pendingPromotion = { fromR, fromC, toR, toC };
            document.getElementById('promotionOverlay').classList.add('active');
            document.getElementById('promotionDialog').classList.add('active');
        }

        document.querySelectorAll('.promotion-piece').forEach(piece => {
            piece.addEventListener('click', function () {
                const promoted = this.dataset.piece.toUpperCase();

                // Hide dialog
                document.getElementById('promotionOverlay').classList.remove('active');
                document.getElementById('promotionDialog').classList.remove('active');

                if (pendingPromotion) {
                    const { fromR, fromC, toR, toC } = pendingPromotion;

                    // Capture piece if any
                    const capturedPiece = board[toR][toC];
                    if (capturedPiece) {
                        capturedByPlayer.push(capturedPiece);
                        updateCapturedPieces();
                    }

                    // Promote pawn
                    board[toR][toC] = promoted;
                    board[fromR][fromC] = "";

                    recordMove(fromR, fromC, toR, toC);
                    lastMove = { from: { row: fromR, col: fromC }, to: { row: toR, col: toC } };

                    clearSelection();
                    clearHintMoves();
                    renderBoard();

                    currentPlayer = 'black';
                    updateStatus('AI is thinking...');

                    // Trigger AI move
                    setTimeout(() => triggerAIMove(), 500);

                    pendingPromotion = null;
                }
            });
        });

        // Handle square click
        async function handleSquareClick(r, c) {
            if (gameOver || currentPlayer === 'black') return;

            const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
            const piece = board[r][c];

            if (selectedSquare) {
                // Attempt a move
                const fromR = selectedSquare.r;
                const fromC = selectedSquare.c;
                const movingPiece = board[fromR][fromC];

                const response = await fetch('/validate_move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        board: board,
                        from: { row: fromR, col: fromC },
                        to: { row: r, col: c }
                    })
                });
                const data = await response.json();

                if (data.valid) {
                    // Save board state for undo
                    boardHistory.push(JSON.parse(JSON.stringify(board)));

                    // Check for pawn promotion
                    if (movingPiece === 'P' && r === 0) {
                        showPromotionDialog(fromR, fromC, r, c);
                        return;
                    }

                    // Execute move
                    const capturedPiece = board[r][c];
                    const move = { from: { row: fromR, col: fromC }, to: { row: r, col: c } };

                    // Handle en passant capture
                    if (movingPiece.toLowerCase() === 'p' && c !== fromC && !capturedPiece) {
                        const enPassantRow = fromR;
                        const enPassantPiece = board[enPassantRow][c];
                        if (enPassantPiece) {
                            capturedByPlayer.push(enPassantPiece);
                            board[enPassantRow][c] = "";
                        }
                    } else if (capturedPiece) {
                        capturedByPlayer.push(capturedPiece);
                    }

                    // Handle castling
                    if (movingPiece === 'K' && Math.abs(c - fromC) === 2) {
                        if (c > fromC) { // Kingside
                            board[7][5] = board[7][7];
                            board[7][7] = "";
                        } else { // Queenside
                            board[7][3] = board[7][0];
                            board[7][0] = "";
                        }
                    }

                    board[r][c] = movingPiece;
                    board[fromR][fromC] = "";

                    updateCapturedPieces();
                    recordMove(fromR, fromC, r, c);
                    lastMove = move;
                    aiInCheck = data.opponent_in_check;

                    clearSelection();
                    clearHintMoves();
                    renderBoard();

                    currentPlayer = 'black';
                    updateStatus('AI is thinking...');

                    setTimeout(() => triggerAIMove(), 500);
                } else {
                    if (data.reason) {
                        updateStatus(data.reason);
                        setTimeout(() => updateStatus(), 2000);
                    }

                    if (piece && isWhitePiece(piece)) {
                        clearSelection();
                        selectedSquare = { r, c };
                        square.classList.add('selected');
                        showHintMoves(r, c);
                    } else {
                        clearSelection();
                    }
                }

            } else if (piece && isWhitePiece(piece)) {
                selectedSquare = { r, c };
                highlightSquare(r, c);
                showHintMoves(r, c);
            }
        }

        // Trigger AI move
        async function triggerAIMove() {
            try {
                const aiResponse = await fetch('/ai_move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        board: board,
                        difficulty: difficulty
                    })
                });
                const aiData = await aiResponse.json();

                if (aiData.success) {
                    board = aiData.board;
                    playerInCheck = aiData.player_in_check;
                    aiInCheck = false;

                    if (aiData.move) {
                        const aiMove = aiData.move;
                        lastMove = aiMove;
                        recordMove(aiMove.from.row, aiMove.from.col, aiMove.to.row, aiMove.to.col, true);

                        if (aiData.captured_piece) {
                            capturedByAI.push(aiData.captured_piece);
                            updateCapturedPieces();
                        }
                    }

                    renderBoard();
                    updateStats(aiData.stats);

                    if (aiData.game_over) {
                        endGame(aiData.winner, aiData.reason);
                    } else {
                        currentPlayer = 'white';
                        updateStatus();
                        enableUndoButton();
                    }
                } else {
                    console.error("AI Move Error:", aiData.error);
                    updateStatus(`AI Error: ${aiData.error}`);
                }
            } catch (error) {
                console.error('AI move fetch error:', error);
                updateStatus('Connection Error');
            }
        }

        // Show hint moves
        async function showHintMoves(r, c) {
            clearHintMoves();

            try {
                const response = await fetch('/validate_move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        board: board,
                        from: { row: r, col: c },
                        to: { row: r, col: c }
                    })
                });

                const data = await response.json();

                if (data.moves_for_piece) {
                    data.moves_for_piece.forEach(move => {
                        const targetSquare = document.querySelector(
                            `[data-row="${move.to.row}"][data-col="${move.to.col}"]`
                        );
                        if (targetSquare) {
                            const piece = board[r][c];
                            const toRow = move.to.row;
                            const toCol = move.to.col;

                            // Check for castling
                            if (piece && piece.toLowerCase() === 'k' && Math.abs(toCol - c) === 2) {
                                targetSquare.classList.add('castling-hint');
                            }
                            // Check for en passant
                            else if (piece && piece.toLowerCase() === 'p' && toCol !== c && !board[toRow][toCol]) {
                                targetSquare.classList.add('en-passant-hint');
                            }
                            // Regular capture
                            else if (board[toRow][toCol]) {
                                targetSquare.classList.add('capture-hint');
                            }
                            // Regular move
                            else {
                                targetSquare.classList.add('move-hint');
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Error fetching legal moves:", error);
            }
        }

        // Update status
        function updateStatus(message = null) {
            const statusMsg = document.getElementById('statusMessage');
            statusMsg.className = 'status-bar';

            if (message) {
                statusMsg.textContent = message;
                if (message.includes('thinking')) {
                    statusMsg.classList.add('thinking');
                }
            } else if (currentPlayer === 'white') {
                statusMsg.textContent = `Turn: Player (White)`;
                if (playerInCheck) {
                    statusMsg.textContent += ' ‚ö†Ô∏è IN CHECK!';
                    statusMsg.classList.add('check-status');
                }
            } else {
                statusMsg.textContent = `Turn: AI (Black) is thinking...`;
                statusMsg.classList.add('thinking');
            }
        }

        // Update stats
        function updateStats(stats) {
            if (!stats) return;
            document.getElementById('gamesPlayed').textContent = stats.games;
            document.getElementById('aiWins').textContent = stats.ai_wins;
            document.getElementById('playerWins').textContent = stats.player_wins;
            document.getElementById('draws').textContent = stats.draws;
            document.getElementById('winRate').textContent = stats.win_rate + '%';
        }

        // End game
        function endGame(winner, reason = 'game over') {
            gameOver = true;
            stopTimer();

            let winMessage = '';
            let emoji = '';

            if (winner === 'white') {
                winMessage = 'You Win!';
                emoji = 'üèÜ';
            } else if (winner === 'black') {
                winMessage = 'AI Wins!';
                emoji = 'ü§ñ';
            } else if (winner === 'draw') {
                winMessage = 'Draw!';
                emoji = 'ü§ù';
            }

            let reasonText = '';
            if (reason === 'checkmate') {
                reasonText = 'CHECKMATE!';
            } else if (reason === 'stalemate') {
                reasonText = 'STALEMATE!';
            } else if (reason === 'insufficient_material') {
                reasonText = 'INSUFFICIENT MATERIAL!';
            } else {
                reasonText = reason.toUpperCase();
            }

            document.getElementById('gameOverTitle').textContent = `${emoji} ${winMessage}`;
            document.getElementById('gameOverMessage').textContent = reasonText;
            document.getElementById('gameOverOverlay').classList.add('active');
            document.getElementById('gameOverModal').classList.add('active');
        }

        // Game Over Modal buttons
        document.getElementById('gameOverNewGame').addEventListener('click', function () {
            document.getElementById('gameOverOverlay').classList.remove('active');
            document.getElementById('gameOverModal').classList.remove('active');

            // Return to difficulty selection
            stopTimer();
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('difficultyScreen').classList.remove('hidden');
        });

        document.getElementById('gameOverContinue').addEventListener('click', function () {
            document.getElementById('gameOverOverlay').classList.remove('active');
            document.getElementById('gameOverModal').classList.remove('active');
        });

        // Undo button
        function enableUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            const undoTimerEl = document.getElementById('undoTimer');

            undoBtn.disabled = false;

            if (undoTimeout) clearTimeout(undoTimeout);
            if (undoCountdown) clearInterval(undoCountdown);

            let timeLeft = 10;
            undoTimerEl.textContent = timeLeft;

            undoCountdown = setInterval(() => {
                timeLeft--;
                undoTimerEl.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(undoCountdown);
                    undoBtn.disabled = true;
                    undoTimerEl.textContent = '';
                }
            }, 1000);

            undoTimeout = setTimeout(() => {
                undoBtn.disabled = true;
                undoTimerEl.textContent = '';
            }, 10000);
        }

        document.getElementById('undoBtn').addEventListener('click', function () {
            if (boardHistory.length >= 2) {
                boardHistory.pop();
                board = JSON.parse(JSON.stringify(boardHistory[boardHistory.length - 1]));

                if (moveHistory.length >= 2) {
                    moveHistory.pop();
                    moveHistory.pop();
                }

                if (capturedByAI.length > 0) capturedByAI.pop();
                if (capturedByPlayer.length > 0) capturedByPlayer.pop();

                currentPlayer = 'white';
                playerInCheck = false;
                aiInCheck = false;
                lastMove = moveHistory[moveHistory.length - 1] || null;

                updateCapturedPieces();
                renderBoard();
                updateStatus();

                const historyEl = document.getElementById('moveHistory');
                historyEl.innerHTML = moveHistory.length === 0
                    ? '<div style="text-align: center; color: #7f8c8d; font-size: 11px;">No moves yet</div>'
                    : moveHistory.map(m => {
                        const piece = board[m.to.row][m.to.col];
                        const fromN = String.fromCharCode(97 + m.from.col) + (8 - m.from.row);
                        const toN = String.fromCharCode(97 + m.to.col) + (8 - m.to.row);
                        return `<div class="move-item">${m.isAI ? 'ü§ñ' : 'üë§'} ${pieces[piece]} ${fromN}‚Üí${toN}</div>`;
                    }).join('');

                this.disabled = true;
                document.getElementById('undoTimer').textContent = '';
                if (undoTimeout) clearTimeout(undoTimeout);
                if (undoCountdown) clearInterval(undoCountdown);
            }
        });

        // Hint button
        document.getElementById('hintBtn').addEventListener('click', async function () {
            if (gameOver || currentPlayer !== 'white') return;

            try {
                const response = await fetch('/get_hint', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ board: board })
                });
                const data = await response.json();

                if (data.success && data.hint) {
                    const hint = data.hint;
                    const fromSquare = document.querySelector(`[data-row="${hint.from.row}"][data-col="${hint.from.col}"]`);
                    const toSquare = document.querySelector(`[data-row="${hint.to.row}"][data-col="${hint.to.col}"]`);

                    // Clear previous hints
                    document.querySelectorAll('.square').forEach(sq => {
                        sq.style.boxShadow = '';
                    });

                    // Highlight suggested move
                    if (fromSquare) fromSquare.style.boxShadow = 'inset 0 0 0 5px #3498db';
                    if (toSquare) toSquare.style.boxShadow = 'inset 0 0 0 5px #2ecc71';

                    updateStatus('üí° Hint: Move highlighted in blue ‚Üí green');
                    setTimeout(() => {
                        if (fromSquare) fromSquare.style.boxShadow = '';
                        if (toSquare) toSquare.style.boxShadow = '';
                        updateStatus();
                    }, 5000);
                }
            } catch (error) {
                console.error('Hint error:', error);
            }
        });

        // Theme toggle
        document.getElementById('themeToggle').addEventListener('click', function () {
            document.getElementById('themePopup').classList.toggle('active');
        });

        document.querySelectorAll('.theme-option').forEach(opt => {
            opt.addEventListener('click', function () {
                const theme = this.dataset.theme;
                const chessboard = document.getElementById('chessboard');

                chessboard.className = 'chessboard theme-' + theme;

                document.querySelectorAll('.theme-option').forEach(o => o.classList.remove('active'));
                this.classList.add('active');

                document.getElementById('themePopup').classList.remove('active');
            });
        });

        // New game button
        document.getElementById('newGameBtn').addEventListener('click', function () {
            if (confirm('Start a new game? Current game will be lost.')) {
                stopTimer();
                // Return to difficulty selection
                document.getElementById('gameContainer').classList.remove('active');
                document.getElementById('difficultyScreen').classList.remove('hidden');
            }
        });

        // Close popups when clicking outside
        document.addEventListener('click', function (e) {
            const popup = document.getElementById('themePopup');
            const toggleBtn = document.getElementById('themeToggle');
            if (!popup.contains(e.target) && !toggleBtn.contains(e.target)) {
                popup.classList.remove('active');
            }
        });
    </script>